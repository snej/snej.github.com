---
layout: post
title: "Doing application updates via version-control"
---
I just had an interesting idea, brought on by a post to an Apple developer list asking about software-update mechanisms for Mac applications. The library everyone uses for this is "Sparkle":http://sparkle.andymatuschak.org/, which is wonderful in all ways _except_ bandwidth usage: it updates the app by downloading an entire zip archive of the new version. With many apps nowadays being 10MB or even 100MB downloads, that's pretty significant.

This could clearly be improved a lot by downloading a "delta":http://en.wikipedia.org/wiki/Delta_encoding instead, then using that to patch the current copy of the app. In most cases, using a good algorithm like "xdelta3":http://xdelta.org or "zdelta":http://cis.poly.edu/zdelta/, the data transmitted will be orders of magnitude smaller than the entire app. (Nothing new here; many app updaters already do this, especially for games, and Microsoft apparently has "some sophisticated delta-based software update tools":http://en.wikipedia.org/wiki/Remote_Differential_Compression in Windows.)

Of course, the delta to be downloaded is specific to which version of the program you already have, as well as which one you're updating to. This means the server will need to keep a number of deltas on hand, and it and the client need to negotiate which one to use.

An additional problem with using deltas for updating Mac applications is that, on OS X, an app isn't a single file but a directory tree masquerading as a file. This means that a patch would have to consist of a tree of deltas, one per file.

I started toying with ways of implementing this, but a minute later my brain chimed in with the observation _"Hey Jens! This is just like what a version-control system does when updating a working tree from a repository!"_ That's what I love about my brain: some fraction of the factoids I cram into it daily will percolate inside and pop out later on at some useful moment. Thanks, brain!

h2. Here's My Idea.

Release your application in the form of a working tree of a distributed version-control system [DVCS] like "Mercurial":http://selenic.com/mercurial (or "Git":http://git.or.cz/, if you must.) That is, the app bundle's "Contents" directory has a ".hg" subdirectory containing the usual Mercurial metadata. This is sort of unusual in that you've checked in the compiled app rather than the source code; but modern DVCSs work fine with binary files.

You also maintain on your server a repository containing all the versions of the application. Whenever you release a new version, you simply check it into that repository as an update of the previous release.

Now, when a copy of the app wants to update itself, it simply does an "hg pull" (or equivalent) of itself from the repository URL. This efficiently determines which files have changed and, for each file, which deltas to download an apply. And it does this without affecting the running app, because the deltas go into the metadata in the ".hg" directory. Then when the pull is complete, the app can prompt the user that it's time to relaunch, then run "hg update" to patch the actual files and quit and re-launch itself.

This has a number of really nice features:

# Checking whether an update is present is quick (DVCS's are optimized for this).
# Downloading updates uses minimal bandwidth because only compressed deltas are sent.
# The DVCS automatically handles updating from any old version.
# Users can even _downgrade_ easily to previous versions. (In fact, switching between previously-downloaded versions can be done offline, since the DVCS metadata retains all the necessary diffs!)
# This mechanism can easily handle beta versions. By treating a beta as a branch, betas can easily be made "opt-in", with users able to switch between beta and stable mode.
# If one user has downloaded an update, another nearby user could efficiently apply the update by pulling directly from that user's copy of the app over the LAN, instead of having to go back to the original server. (Or alternatively, the DVCS can package the update into a patch-file that can be sent to the other computer and applied there.)

The only drawbacks I can see to this are:

# The DVCS software needs to be available on every user's machine. Since none of these ship with the OS, it would probably have to be packaged inside the app as part of the software-update library. That's a significant amount of code (Mercurial is about 2MB, and I think Git is a lot bigger.)
# The local app's revision metadata is a full repository that includes prior versions. You clearly don't want to ship it that way. I believe DVCSs all support a way of pruning old revisions from a repository, though.

I'm not promising to implement this, but it's so cool that _someone_ needs to give it a try. And if it's been done already, I'd be interested to hear about how well it worked.