---
layout: post
title: "MacRuby"
---
"MacRuby":http://trac.macosforge.org/projects/ruby/wiki/MacRuby "is a version of Ruby that runs on top of Objective-C. More precisely, MacRuby is currently a port of the Ruby 1.9 implementation for the Objective-C runtime and garbage collector. The rationale behind this effort is to solve in a very efficient way all the bridging problems RubyCocoa, the Ruby bridge to the Objective-C runtime, has to work around." (It's still in development, and not ready for prime-time use yet.)

This is exciting news. Now, Mac OS X already has excellent Ruby support, with <a href="http://developer.apple.com/tools/developonrailsleopard.html">a complete Ruby 1.8 and Rails stack</a> (including extras like Mongrel and Capistrano) included in the box. There's also a glue library called RubyCocoa that bridges between the Ruby and Objective-C languages, making it easy to write all or part of a Cocoa app in Ruby (or to call useful Obj-C frameworks from a Ruby app.)

So why MacRuby? The big deal is _performance_. By re-implementing the Ruby object model on top of the Objective-C runtime — so all Ruby objects are bona fide Objective-C objects and vice versa — it will eliminate "serious amounts of overhead":http://trac.macosforge.org/projects/ruby/wiki/WhyMacRuby:

* Parameter marshalling whenever a Ruby method has to call into Objective-C or vice versa
* Bookkeeping data structures that map between Ruby and Objective-C objects and classes
* Incompatible threading models
* Multiple garbage collectors

It also takes advantage of the major speed boost of the new bytecode interpreter in Ruby 1.9.

From my experiences working on Apple's Java runtime, I know that bridging to and from native code is a major performance issue. The amount of overhead for a single inter-language call may not seem like much (a few microseconds), but it's one of those "death by a thousand cuts" effects, because in an application that uses native libraries it happens so often.

(For example, one of the ways I was able to speed up AWT graphics performance by about 5x in MRJ 2.1 was to pipeline the calls, so instead of each java.awt.Graphics method calling directly into the native QuickDraw API, it just appended the parameters to a display-list array, which periodically got flushed through a single call to a native C++ method that walked the list and made all the QuickDraw calls. I didn't initially believe this would be a big win, but Steve Zellers wrote a prototype version that proved it.)

Another nice feature of MacRuby is that it slightly extends Ruby's method-call syntax to allow Objective-C style interleaved keywords and arguments. So when calling an Objective-C -setFirstName:lastName: method, instead of writing
<pre>    person.setFirstName_lastName(first,last)</pre>
you write
<pre>    person.setFirstName first, lastName: last</pre>
or alternatively
<pre>    person.setFirstName first, :lastName => last</pre>
This may offend Ruby purists, and it's really just syntactic sugar, but by eliminating _conceptual_ bridging overhead, I think it'll improve _programmer_ performance, which is also an important optimization.

Finally, another good thing that I didn't realize right away is that it's an official Apple open-source project. So not only does that make it very likely that a finished version of MacRuby will be built into 10.6; it also means that, if it's necessary to tweak the Objective-C runtime to make MacRuby work better, that's likely to happen too. The people working on runtimes and scripting languages at Apple are _really smart_, and I'm glad to see they're not resting on their laurels after all they achieved in 10.5.